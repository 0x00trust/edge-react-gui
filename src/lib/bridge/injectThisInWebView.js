// @flow
export const javascript =
  "'use strict';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/**\n * @file\n * Bridgeable objects have a special \"magic\" property.\n * This file contains routines for working with these magic properties.\n */\n// An object is bridgeable if it has this key:\nvar MAGIC_KEY = '_yaob';\n/**\n * Magic data used to mark classes as bridgeable.\n */\n\nvar nextLocalId = 1;\nvar sharedData = {};\n/**\n * Adds or updates an object's magic data.\n */\n\nfunction addMagic(o, magic) {\n  if (Object.prototype.hasOwnProperty.call(o, MAGIC_KEY)) {\n    _extends(o[MAGIC_KEY], magic);\n  } else {\n    Object.defineProperty(o, MAGIC_KEY, {\n      value: magic\n    });\n  }\n}\n/**\n * Makes a class bridgeable, including anything derived from it.\n */\n\n\nfunction bridgifyClass(Class) {\n  var o = Class.prototype;\n\n  if (!Object.prototype.hasOwnProperty.call(o, MAGIC_KEY)) {\n    var magic = {};\n    addMagic(o, magic);\n  }\n}\n/**\n * Makes an object instance bridgeable.\n */\n\nfunction bridgifyObject(o) {\n  if (!Object.prototype.hasOwnProperty.call(o, MAGIC_KEY) || o[MAGIC_KEY].localId == null) {\n    var magic = {\n      localId: nextLocalId++,\n      bridges: [],\n      listeners: {},\n      watchers: {}\n    };\n    addMagic(o, magic);\n  }\n}\n/**\n * Gets the magic data from an object instance.\n */\n\nfunction getInstanceMagic(o) {\n  // We only want to look at bridgeable objects:\n  if (o[MAGIC_KEY] == null) throw new TypeError('Not a bridgeable object');\n  bridgifyObject(o);\n  return o[MAGIC_KEY];\n}\n/**\n * Creates a new `ProxyMagic` object.\n */\n\nfunction makeProxyMagic(remoteId) {\n  return {\n    // InstanceMagic:\n    localId: nextLocalId++,\n    bridges: [],\n    listeners: {},\n    watchers: {},\n    // ProxyMagic:\n    remoteId: remoteId,\n    errors: {},\n    props: {}\n  };\n}\n/**\n * Adds items to the global shared data table.\n */\n\nfunction shareData(table, namespace) {\n  if (namespace == null) namespace = '';else namespace += '.';\n\n  for (var _i2 = 0, _Object$getOwnPropert2 = Object.getOwnPropertyNames(table); _i2 < _Object$getOwnPropert2.length; _i2++) {\n    var n = _Object$getOwnPropert2[_i2];\n    var shareId = namespace + n;\n\n    if (sharedData[shareId] != null) {\n      throw new Error(\"A shared value named \" + shareId + \" already exists\");\n    }\n\n    sharedData[shareId] = table[n];\n    addMagic(table[n], {\n      shareId: shareId\n    });\n  }\n}\n\n/**\n * The data-packing system uses this interface to turn\n * bridgeable objects into packedId's and vice-versa.\n */\n\n// Object properties\n\n/**\n * Prepares a value for sending over the wire.\n */\nfunction packData(table, data) {\n  try {\n    var map = mapData(table, data);\n    var raw = packItem(table, map, data);\n    return map !== '' ? {\n      map: map,\n      raw: raw\n    } : {\n      raw: raw\n    };\n  } catch (data) {\n    return packThrow(table, data);\n  }\n}\n/**\n * Prepares a thrown value for sending over the wire.\n */\n\nfunction packThrow(table, data) {\n  var map = mapData(table, data);\n  var raw = packItem(table, map, data);\n  return {\n    map: map,\n    raw: raw,\n    throw: true\n  };\n}\n/**\n * Restores a value that has been sent over the wire.\n */\n\nfunction unpackData(table, data, path) {\n  var map = data.map,\n      raw = data.raw;\n  var out = map != null ? unpackItem(table, map, raw, path) : raw;\n  if (data.throw) throw out;\n  return out;\n}\n/**\n * Searches through a value, looking for data we can't send directly.\n * Returns a map showing where fixes need to take place.\n */\n\nfunction mapData(table, data) {\n  switch (typeof data) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return '';\n\n    case 'object':\n      if (data === null) return '';\n      if (data instanceof Date) return 'd';\n      if (data instanceof Error) return 'e';\n\n      if (data[MAGIC_KEY] != null) {\n        return data[MAGIC_KEY].shareId != null ? 's' : 'o';\n      } // Arrays:\n\n\n      if (Array.isArray(data)) {\n        var _out = '';\n\n        for (var i = 0; i < data.length; ++i) {\n          var map = mapData(table, data[i]);\n\n          if (map !== '' && _out === '') {\n            _out = [];\n\n            for (var j = 0; j < i; ++j) {\n              _out[j] = '';\n            }\n          }\n\n          if (_out !== '') _out[i] = map;\n        }\n\n        return _out;\n      } // Data objects:\n\n\n      var out = '';\n\n      for (var n in data) {\n        var _map = mapData(table, data[n]);\n\n        if (_map !== '') {\n          if (out === '') out = {};\n          out[n] = _map;\n        }\n      }\n\n      return out;\n\n    case 'undefined':\n      return 'u';\n\n    case 'function':\n      return data[MAGIC_KEY] != null && data[MAGIC_KEY].shareId != null ? 's' : '?';\n\n    default:\n      return '?';\n  }\n}\n/**\n * Breaks down an error object into a JSON representation.\n */\n\n\nfunction packError(table, o) {\n  // Grab the properties off the object:\n  var message = o.message,\n      stack = o.stack;\n\n  var props = _extends({\n    message: message,\n    stack: stack\n  }, o);\n\n  var base = null;\n  if (o instanceof EvalError) base = 'EvalError';else if (o instanceof RangeError) base = 'RangeError';else if (o instanceof ReferenceError) base = 'ReferenceError';else if (o instanceof SyntaxError) base = 'SyntaxError';else if (o instanceof TypeError) base = 'TypeError';else if (o instanceof URIError) base = 'URIError'; // Build the JSON value:\n\n  return _extends({\n    base: base\n  }, packData(table, props));\n}\n/**\n * Copies a value, removing any API objects identified in the types.\n */\n\n\nfunction packItem(table, map, data) {\n  switch (map) {\n    case '':\n      return data;\n\n    case '?':\n      return typeof data;\n\n    case 'd':\n      return data.toISOString();\n\n    case 'e':\n      return packError(table, data);\n\n    case 'o':\n      return table.getPackedId(data);\n\n    case 's':\n      return data[MAGIC_KEY].shareId;\n\n    case 'u':\n      return null;\n\n    default:\n      // Arrays:\n      if (Array.isArray(map)) {\n        var _out2 = [];\n\n        for (var i = 0; i < map.length; ++i) {\n          _out2[i] = packItem(table, map[i], data[i]);\n        }\n\n        return _out2;\n      } // Objects:\n\n\n      var out = {};\n\n      for (var n in data) {\n        out[n] = n in map ? packItem(table, map[n], data[n]) : data[n];\n      }\n\n      return out;\n  }\n}\n/**\n * Restores an error object from its JSON representation.\n */\n\n\nfunction unpackError(table, value, path) {\n  var bases = {\n    EvalError: EvalError,\n    RangeError: RangeError,\n    ReferenceError: ReferenceError,\n    SyntaxError: SyntaxError,\n    TypeError: TypeError,\n    URIError: URIError // Make the object:\n\n  };\n  var Base = value.base != null ? bases[value.base] || Error : Error;\n  var out = new Base(); // Restore the properties:\n\n  var props = unpackData(table, value, path);\n\n  for (var n in props) {\n    out[n] = props[n];\n  }\n\n  return out;\n}\n/**\n * Restores a value that has been sent over the wire.\n */\n\n\nfunction unpackItem(table, map, raw, path) {\n  switch (map) {\n    case '':\n      return raw;\n\n    case '?':\n      var type = typeof raw === 'string' ? raw : '?';\n      throw new TypeError(\"Unsupported value of type \" + type + \" at \" + path);\n\n    case 'd':\n      return new Date(raw);\n\n    case 'e':\n      if (typeof raw !== 'object' || raw === null) {\n        throw new TypeError(\"Expecting an error description at \" + path);\n      }\n\n      return unpackError(table, raw, path);\n\n    case 'o':\n      if (raw === null) {\n        throw new TypeError(\"Closed bridge object at \" + path);\n      }\n\n      if (typeof raw !== 'number') {\n        throw new TypeError(\"Expecting a packedId at \" + path);\n      }\n\n      var _o = table.getObject(-raw);\n\n      if (_o == null) throw new RangeError(\"Invalid packedId \" + raw + \" at \" + path);\n      return _o;\n\n    case 's':\n      if (typeof raw !== 'string') {\n        throw new TypeError(\"Expecting a shareId at \" + path);\n      }\n\n      var s = sharedData[raw];\n      if (s == null) throw new RangeError(\"Invalid shareId '\" + raw + \"' at \" + path);\n      return s;\n\n    case 'u':\n      return void 0;\n\n    default:\n      if (typeof map !== 'object' || map === null) {\n        throw new TypeError(\"Invalid type information \" + map + \" at \" + path);\n      }\n\n      if (typeof raw !== 'object' || raw === null) {\n        throw new TypeError(\"Expecting an array or object at \" + path);\n      } // Arrays:\n\n\n      if (Array.isArray(map)) {\n        if (!Array.isArray(raw)) {\n          throw new TypeError(\"Expecting an array at \" + path);\n        }\n\n        var _out3 = [];\n\n        for (var i = 0; i < map.length; ++i) {\n          _out3[i] = unpackItem(table, map[i], raw[i], path + \"[\" + i + \"]\");\n        }\n\n        return _out3;\n      } // Objects:\n\n\n      var out = {};\n\n      for (var n in raw) {\n        out[n] = n in map ? unpackItem(table, map[n], raw[n], path + \".\" + n) : raw[n];\n      }\n\n      return out;\n  }\n}\n\n/**\n * @file\n * Functions for managing updates, events, and object lifetime.\n */\n/**\n * Undoes the effect of `on`.\n */\n\n// No user-supplied value will ever be identical to this.\nvar dirtyValue = {};\n/**\n * Subscribes to an event on a bridgeable object.\n */\n\nfunction addListener(o, name, f) {\n  var _getInstanceMagic = getInstanceMagic(o),\n      closed = _getInstanceMagic.closed,\n      listeners = _getInstanceMagic.listeners;\n\n  if (closed) return function () {};\n  if (listeners[name] == null) listeners[name] = [f];else listeners[name].push(f);\n  return function unsubscribe() {\n    listeners[name] = listeners[name].filter(function (i) {\n      return i !== f;\n    });\n  };\n}\n/**\n * Subscribes to property changes on a bridgeable object.\n */\n\nfunction addWatcher(o, name, f) {\n  var _getInstanceMagic2 = getInstanceMagic(o),\n      closed = _getInstanceMagic2.closed,\n      watchers = _getInstanceMagic2.watchers; // Don't catch access errors, since we want the user to see them:\n\n\n  var data = o[name];\n  if (closed) return function () {};\n  if (watchers[name] == null) watchers[name] = {\n    data: data,\n    fs: [f]\n  };else watchers[name].fs.push(f);\n  return function unsubscribe() {\n    watchers[name].fs = watchers[name].fs.filter(function (i) {\n      return i !== f;\n    });\n  };\n}\n/**\n * Destroys a proxy.\n * The remote client will completely forget about this object,\n * and accessing it will become an error.\n */\n\nfunction close(o) {\n  var magic = getInstanceMagic(o);\n  magic.closed = true;\n\n  for (var _i2 = 0, _magic$bridges2 = magic.bridges; _i2 < _magic$bridges2.length; _i2++) {\n    var bridge = _magic$bridges2[_i2];\n    bridge.emitClose(magic.localId);\n  }\n\n  magic.bridges = [];\n  magic.listeners = {};\n  magic.watchers = {};\n}\n/**\n * Emits an event on a bridgeable object.\n */\n\nfunction emit(o, name, payload) {\n  var magic = getInstanceMagic(o);\n  if (magic.closed) throw new Error('Cannot emit event on closed object'); // Schedule outgoing event messages:\n\n  for (var _i4 = 0, _magic$bridges4 = magic.bridges; _i4 < _magic$bridges4.length; _i4++) {\n    var bridge = _magic$bridges4[_i4];\n    bridge.emitEvent(magic.localId, name, payload);\n  } // Call local callbacks:\n\n\n  var listeners = magic.listeners[name];\n\n  if (listeners != null) {\n    for (var _i6 = 0; _i6 < listeners.length; _i6++) {\n      var _f = listeners[_i6];\n      callCallback(o, _f, payload, name !== 'error');\n    }\n  }\n}\n/**\n * Marks an object as having changes. The proxy server will send an update.\n */\n\nfunction update(o, name) {\n  var magic = getInstanceMagic(o);\n  if (magic.closed) throw new Error('Cannot update closed object');\n\n  for (var _i8 = 0, _magic$bridges6 = magic.bridges; _i8 < _magic$bridges6.length; _i8++) {\n    var bridge = _magic$bridges6[_i8];\n    bridge.markDirty(magic.localId, name);\n  } // Blow away the cache if we have a name:\n\n\n  if (name != null && magic.watchers[name] != null) {\n    magic.watchers[name].data = dirtyValue;\n  } // Call watcher callbacks:\n\n\n  for (var n in magic.watchers) {\n    var cache = magic.watchers[n];\n\n    try {\n      var data = o[n];\n\n      if (data !== cache.data) {\n        cache.data = data;\n\n        for (var _i10 = 0, _cache$fs2 = cache.fs; _i10 < _cache$fs2.length; _i10++) {\n          var _f2 = _cache$fs2[_i10];\n          callCallback(o, _f2, cache.data, true);\n        }\n      }\n    } catch (e) {}\n  }\n}\n/**\n * Calls a user-supplied callback function with error checking.\n */\n\nfunction callCallback(o, f, payload, emitError) {\n  try {\n    var out = f(payload); // If the function returns a promise, emit an error if it rejects:\n\n    if (emitError && out != null && typeof out.then === 'function') {\n      out.then(void 0, function (e) {\n        return emit(o, 'error', e);\n      });\n    }\n  } catch (e) {\n    if (emitError) emit(o, 'error', e);\n  }\n}\n\n/**\n * @file\n * Routines for breaking bridgeable objects into messages,\n * and then restoring those messages into proxies on the other side.\n */\n// No user-supplied value will ever be identical to this.\nvar dirtyValue$1 = {};\n/**\n * Examines a bridgeable object and prepares it for sending of the wire.\n * Returns a creation method an the initial value cache.\n */\n\nfunction packObject(state, o) {\n  // Iterate the prototype chain, looking for property names:\n  var allNames = {};\n  var end = Object.prototype;\n\n  for (var p = o; p !== end && p != null; p = Object.getPrototypeOf(p)) {\n    for (var _i2 = 0, _Object$getOwnPropert2 = Object.getOwnPropertyNames(p); _i2 < _Object$getOwnPropert2.length; _i2++) {\n      var _name = _Object$getOwnPropert2[_i2];\n\n      if (_name !== MAGIC_KEY && !/^_/.test(_name) && _name !== 'constructor') {\n        allNames[_name] = true;\n      }\n    }\n  } // Iterate over the object's properties and add their names to\n  // the method list or the value cache.\n\n\n  var cache = {};\n  var methods = [];\n  var props = {};\n\n  for (var n in allNames) {\n    try {\n      var data = o[n];\n\n      if (typeof data === 'function' && (data[MAGIC_KEY] == null || data[MAGIC_KEY].shareId == null)) {\n        methods.push(n);\n      } else {\n        cache[n] = data;\n        props[n] = packData(state, data);\n      }\n    } catch (e) {\n      cache[n] = dirtyValue$1;\n      props[n] = packThrow(state, e);\n    }\n  }\n\n  var _getInstanceMagic = getInstanceMagic(o),\n      localId = _getInstanceMagic.localId;\n\n  var create = {\n    localId: localId,\n    methods: methods,\n    props: props\n  };\n  return {\n    cache: cache,\n    create: create\n  };\n}\n/**\n * Checks an object for changes.\n * Updates the cache, and returns an object with the necessary changes.\n */\n\nfunction diffObject(state, o, cache) {\n  var dirty = false;\n  var props = {};\n\n  for (var n in cache) {\n    try {\n      var value = o[n];\n\n      if (value !== cache[n]) {\n        dirty = true;\n        props[n] = packData(state, value);\n        cache[n] = value;\n      }\n    } catch (e) {\n      props[n] = packThrow(state, e);\n      cache[n] = dirtyValue$1;\n    }\n  }\n\n  return {\n    dirty: dirty,\n    props: props\n  };\n}\n/**\n * Creates an object proxy.\n * The object will have the same values and methods as the original,\n * but will send everything over the bridge.\n */\n\nfunction makeProxy(state, create) {\n  var props = {}; // Make the magic property descriptor:\n\n  var magic = makeProxyMagic(create.localId);\n  props[MAGIC_KEY] = {\n    value: magic // Add the getters:\n\n  };\n\n  for (var n in create.props) {\n    props[n] = {\n      get: makeProxyGetter(magic, n)\n    };\n  } // Add the methods:\n\n\n  for (var _i4 = 0, _create$methods2 = create.methods; _i4 < _create$methods2.length; _i4++) {\n    var _n = _create$methods2[_i4];\n    props[_n] = {\n      value: makeProxyMethod(state, magic, _n)\n    };\n  } // Make the object:\n\n\n  return Object.create(Object.prototype, props);\n}\n/**\n * Unpacks a proxy's properties into the magic storage area.\n */\n\nfunction updateObjectProps(state, o, props) {\n  var magic = o[MAGIC_KEY];\n\n  for (var n in props) {\n    try {\n      magic.props[n] = unpackData(state, props[n], n);\n      magic.errors[n] = false;\n    } catch (e) {\n      magic.props[n] = e;\n      magic.errors[n] = true;\n    }\n  }\n}\n\nfunction makeProxyGetter(magic, name) {\n  return function get() {\n    if (magic.errors[name]) throw magic.props[name];\n    return magic.props[name];\n  };\n}\n\nfunction makeProxyMethod(state, magic, name) {\n  return function method() {\n    if (magic.closed) {\n      return Promise.reject(new TypeError(\"Cannot call method '\" + name + \"' of closed proxy\"));\n    }\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return state.emitCall(magic.remoteId, name, args);\n  };\n}\n\nvar BridgeState =\n/*#__PURE__*/\nfunction () {\n  // Objects:\n  // Outgoing method calls:\n  // Pending message:\n  // Update scheduling:\n  function BridgeState(opts) {\n    var sendMessage = opts.sendMessage,\n        _opts$throttleMs = opts.throttleMs,\n        throttleMs = _opts$throttleMs === void 0 ? 0 : _opts$throttleMs; // Objects:\n\n    this.proxies = {};\n    this.objects = {};\n    this.caches = {}; // Outgoing method calls:\n\n    this.nextCallId = 0;\n    this.pendingCalls = {}; // Pending message:\n\n    this.dirty = {};\n    this.message = {}; // Update scheduling:\n\n    this.throttleMs = throttleMs;\n    this.lastUpdate = 0;\n    this.sendPending = false;\n    this.sendMessage = sendMessage;\n  }\n  /**\n   * Grabs an object by its proxy id.\n   */\n\n\n  var _proto = BridgeState.prototype;\n\n  _proto.getObject = function getObject(packedId) {\n    return packedId < 0 ? this.proxies[-packedId] : this.objects[packedId];\n  };\n  /**\n   * Returns an object's id relative to this bridge.\n   * The id is positive for objects created on this side of the bridge,\n   * and negative for proxy objects reflecting things on the other side.\n   */\n\n\n  _proto.getPackedId = function getPackedId(o) {\n    var magic = getInstanceMagic(o);\n    if (magic.closed) return null;\n\n    if (magic.remoteId != null && this.proxies[magic.remoteId] != null) {\n      return -magic.remoteId;\n    }\n\n    if (this.objects[magic.localId] == null) {\n      // Add unknown objects to the bridge:\n      this.objects[magic.localId] = o;\n\n      var _packObject = packObject(this, o),\n          cache = _packObject.cache,\n          create = _packObject.create;\n\n      this.caches[magic.localId] = cache;\n      magic.bridges.push(this);\n      this.emitCreate(create, o);\n    }\n\n    return magic.localId;\n  };\n  /**\n   * Marks an object as needing changes.\n   */\n\n\n  _proto.markDirty = function markDirty(localId, name) {\n    var cache = this.caches[localId];\n    if (name != null && name in cache) cache[name] = dirtyValue$1;\n    this.dirty[localId] = {\n      cache: cache,\n      object: this.objects[localId]\n    };\n    this.wakeup();\n  };\n  /**\n   * Marks an object as being deleted.\n   */\n\n\n  _proto.emitClose = function emitClose(localId) {\n    delete this.objects[localId];\n    delete this.caches[localId];\n    if (this.message.closed == null) this.message.closed = [];\n    this.message.closed.push(localId);\n    this.wakeup();\n  };\n  /**\n   * Attaches an object to this bridge, sending a creation message.\n   */\n\n\n  _proto.emitCreate = function emitCreate(create, o) {\n    if (this.message.created == null) this.message.created = [];\n    this.message.created.push(create); // this.wakeup() not needed, since this is part of data packing.\n  };\n  /**\n   * Enqueues a proxy call message.\n   */\n\n\n  _proto.emitCall = function emitCall(remoteId, name, args) {\n    var _this = this;\n\n    var callId = this.nextCallId++;\n\n    var message = _extends({\n      callId: callId,\n      remoteId: remoteId,\n      name: name\n    }, packData(this, args));\n\n    if (this.message.calls == null) this.message.calls = [];\n    this.message.calls.push(message);\n    this.wakeup();\n    return new Promise(function (resolve, reject) {\n      _this.pendingCalls[callId] = {\n        resolve: resolve,\n        reject: reject\n      };\n    });\n  };\n  /**\n   * Enqueues an event message.\n   */\n\n\n  _proto.emitEvent = function emitEvent(localId, name, payload) {\n    var message = _extends({\n      localId: localId,\n      name: name\n    }, packData(this, payload));\n\n    if (this.message.events == null) this.message.events = [];\n    this.message.events.push(message);\n    this.wakeup();\n  };\n  /**\n   * Enqueues a function return message.\n   */\n\n\n  _proto.emitReturn = function emitReturn(callId, fail, value) {\n    var message = _extends({\n      callId: callId\n    }, fail ? packThrow(this, value) : packData(this, value));\n\n    if (this.message.returns == null) this.message.returns = [];\n    this.message.returns.push(message);\n    this.wakeup();\n  };\n  /**\n   * Handles an incoming message,\n   * updating state and triggering side-effects as needed.\n   */\n\n\n  _proto.handleMessage = function handleMessage(message) {\n    var _this2 = this;\n\n    // ----------------------------------------\n    // Phase 1: Get our proxies up to date.\n    // ----------------------------------------\n    // Handle newly-created objects:\n    if (message.created) {\n      // Pass 1: Create proxies for the new objects:\n      for (var _i2 = 0, _message$created2 = message.created; _i2 < _message$created2.length; _i2++) {\n        var create = _message$created2[_i2];\n        this.proxies[create.localId] = makeProxy(this, create);\n      } // Pass 2: Fill in the values:\n\n\n      for (var _i4 = 0, _message$created4 = message.created; _i4 < _message$created4.length; _i4++) {\n        var _create = _message$created4[_i4];\n        updateObjectProps(this, this.proxies[_create.localId], _create.props);\n      }\n    } // Handle updated objects:\n\n\n    if (message.changed) {\n      // Pass 1: Update all the proxies:\n      for (var _i6 = 0, _message$changed2 = message.changed; _i6 < _message$changed2.length; _i6++) {\n        var change = _message$changed2[_i6];\n        var _localId = change.localId,\n            props = change.props;\n        var o = this.proxies[_localId];\n\n        if (o == null) {\n          throw new RangeError(\"Invalid localId \" + _localId);\n        }\n\n        updateObjectProps(this, o, props);\n      } // Pass 2: Fire the callbacks:\n\n\n      for (var _i8 = 0, _message$changed4 = message.changed; _i8 < _message$changed4.length; _i8++) {\n        var _change = _message$changed4[_i8];\n        update(this.proxies[_change.localId]);\n      }\n    } // ----------------------------------------\n    // Phase 2: Handle events & method calls\n    // ----------------------------------------\n    // Handle events:\n\n\n    if (message.events) {\n      for (var _i10 = 0, _message$events2 = message.events; _i10 < _message$events2.length; _i10++) {\n        var event = _message$events2[_i10];\n        var _localId2 = event.localId,\n            name = event.name;\n\n        var _o = _localId2 === 0 ? this : this.proxies[_localId2];\n\n        if (_o == null) continue;\n\n        try {\n          emit(_o, name, unpackData(this, event, name));\n        } catch (e) {\n          emit(_o, 'error', e); // Payload unpacking problem\n        }\n      }\n    } // Handle method calls:\n\n\n    if (message.calls) {\n      var _loop = function _loop(_i12, _message$calls2) {\n        var call = _message$calls2[_i12];\n        var callId = call.callId,\n            remoteId = call.remoteId,\n            name = call.name;\n\n        try {\n          var _o2 = _this2.objects[remoteId];\n\n          if (_o2 == null) {\n            throw new TypeError(\"Cannot call method '\" + name + \"' of closed proxy (remote)\");\n          }\n\n          if (typeof _o2[name] !== 'function') {\n            throw new TypeError(\"'\" + name + \"' is not a function\");\n          }\n\n          var args = unpackData(_this2, call, name + \".arguments\");\n          Promise.resolve(_o2[name].apply(_o2, args)).then(function (value) {\n            return _this2.emitReturn(callId, false, value);\n          }, function (e) {\n            return _this2.emitReturn(callId, true, e);\n          });\n        } catch (e) {\n          _this2.emitReturn(callId, true, e);\n        }\n      };\n\n      for (var _i12 = 0, _message$calls2 = message.calls; _i12 < _message$calls2.length; _i12++) {\n        _loop(_i12, _message$calls2);\n      }\n    } // Handle method returns:\n\n\n    if (message.returns) {\n      for (var _i14 = 0, _message$returns2 = message.returns; _i14 < _message$returns2.length; _i14++) {\n        var ret = _message$returns2[_i14];\n        var _callId = ret.callId;\n        var pendingCall = this.pendingCalls[_callId];\n\n        if (pendingCall == null) {\n          throw new RangeError(\"Invalid callId \" + _callId);\n        }\n\n        try {\n          pendingCall.resolve(unpackData(this, ret, '<return>'));\n        } catch (e) {\n          pendingCall.reject(e);\n        } finally {\n          delete this.pendingCalls[_callId];\n        }\n      }\n    } // ----------------------------------------\n    // Phase 3: Clean up closed objects\n    // ----------------------------------------\n\n\n    if (message.closed) {\n      for (var _i16 = 0, _message$closed2 = message.closed; _i16 < _message$closed2.length; _i16++) {\n        var _localId3 = _message$closed2[_i16];\n        var _o3 = this.proxies[_localId3];\n        if (_o3 == null) return;\n        delete this.proxies[_localId3];\n        close(_o3);\n      }\n    }\n  };\n  /**\n   * Sends the current message.\n   */\n\n\n  _proto.sendNow = function sendNow() {\n    // Build change messages:\n    for (var id in this.dirty) {\n      var _localId4 = Number(id);\n\n      var _this$dirty$_localId = this.dirty[_localId4],\n          object = _this$dirty$_localId.object,\n          cache = _this$dirty$_localId.cache;\n\n      var _diffObject = diffObject(this, object, cache),\n          dirty = _diffObject.dirty,\n          props = _diffObject.props;\n\n      if (dirty) {\n        var _message = {\n          localId: _localId4,\n          props: props\n        };\n        if (this.message.changed == null) this.message.changed = [];\n        this.message.changed.push(_message);\n      }\n    }\n\n    var message = this.message;\n    this.dirty = {};\n    this.message = {};\n    this.sendMessage(message);\n  };\n  /**\n   * Something has changed, so prepare to send the pending message:\n   */\n\n\n  _proto.wakeup = function wakeup() {\n    var _this3 = this;\n\n    if (this.sendPending) return;\n    this.sendPending = true;\n\n    var task = function task() {\n      _this3.sendPending = false;\n      _this3.lastUpdate = Date.now();\n\n      _this3.sendNow();\n    }; // We really do want `setTimeout` here, even if the delay is 0,\n    // since promises and other micro tasks should fire first.\n\n\n    var delay = this.lastUpdate + this.throttleMs - Date.now();\n    setTimeout(task, delay < 0 ? 0 : delay);\n  };\n\n  return BridgeState;\n}();\nbridgifyClass(BridgeState);\n\n/**\n * The bridge sends messages using this function.\n */\n\n/**\n * An object bridge.\n */\nvar Bridge =\n/*#__PURE__*/\nfunction () {\n  function Bridge(opts) {\n    var _this = this;\n\n    this._state = new BridgeState(opts);\n    this._rootPromise = new Promise(function (resolve) {\n      return addListener(_this._state, 'root', resolve);\n    });\n  }\n\n  var _proto = Bridge.prototype;\n\n  _proto.handleMessage = function handleMessage(message) {\n    this._state.handleMessage(message);\n  };\n\n  _proto.getRoot = function getRoot() {\n    return this._rootPromise;\n  };\n\n  _proto.sendRoot = function sendRoot(root) {\n    this._state.emitEvent(0, 'root', root);\n  };\n\n  return Bridge;\n}();\n\n/**\n * The `on` function,\n * but packaged as a method and ready to be placed on an object.\n */\n\nvar onMethod = function on(name, f) {\n  return addListener(this, name, f);\n};\n/**\n * The `watch` function,\n * but packaged as a method and ready to be placed on an object.\n */\n\nvar watchMethod = function watch(name, f) {\n  return addWatcher(this, name, f);\n};\nshareData({\n  onMethod: onMethod,\n  watchMethod: watchMethod\n});\n/**\n * The base class for all bridgeable API's. Provides callback capability.\n */\n\nvar Bridgeable =\n/*#__PURE__*/\nfunction () {\n  function Bridgeable() {}\n\n  var _proto = Bridgeable.prototype;\n\n  _proto._close = function _close() {\n    close(this);\n  };\n\n  _proto._emit = function _emit(name, payload) {\n    return emit(this, name, payload);\n  };\n\n  _proto._update = function _update(name) {\n    update(this, name);\n  };\n\n  return Bridgeable;\n}(); // Put the shared methods onto the prototype:\n\nvar hack = Bridgeable.prototype;\nhack.on = onMethod;\nhack.watch = watchMethod;\nbridgifyClass(Bridgeable);\n\nsetTimeout(function () {\n  window.bridge = new Bridge({\n    sendMessage: message => window.postMessage(JSON.stringify(message)),\n  });\n  window.bridge.getRoot()\n    .then(api => {\n      window.edgeApi = api;\n    });\n}, 1000);\n"
